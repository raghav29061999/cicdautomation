# Agentic QA Studio — How It Works

Agentic QA Studio is an AI-led, deterministic quality engineering system that converts a **user story** into **executable tests** and **execution reports** using a structured agentic pipeline built on **LangGraph**.

This document explains:
- What artifacts the system generates
- How to run the system
- How LangGraph is used for orchestration

---

## Artifacts Generated

For every execution (identified by a `run_id`), the system produces the following artifacts.

---

## Phase 1 — Story Understanding

Generated by the LLM using a strict JSON contract:

- **CanonicalUserStoryCIR.json**  
  Canonical interpretation of the user story with acceptance criteria, actors, actions, and constraints.

- **CoverageIntent.json**  
  Explicit statement of what should be tested and why.

- **AmbiguityReport.json**  
  Identifies unclear or missing requirements without inventing behavior.

---

## Phase 2 — Test Design

- **TestCases.json**  
  Deterministic, traceable test cases:
  - Stable test IDs
  - Mapped to acceptance criteria
  - Preconditions, steps, and expected outcomes

---

## Phase 3 — Test Data

- **TestData.json** (optional)  
  Either:
  - Generated by the system, or
  - Ingested from user-provided JSON/XLSX

All test data is schema-validated and referenced by test cases.

---

## Phase 4 — Gherkin Specifications

- One `.feature` file per scenario
- Business-readable Gherkin
- Traceability preserved in comments
- No IDs embedded in steps

**Example:**

```gherkin
# TestCase: TC-002
# AcceptanceCriteria: AC-2
# Dataset: DS-002
Feature: Product Search Filtering

  Scenario: Filter products by brand and price
    Given the user is on the search results page
    When the user applies a brand filter
    And sets a price range
    Then only matching products are displayed
## Phase 5 — Execution (Playwright)

### Execution Artifacts

- **execution/report.json**  
  Machine-readable execution results:
  - Passed / Failed / Skipped
  - Error messages
  - Screenshot paths

- **execution/report.pdf**  
  Human-readable summary for demos and stakeholders.

- **Screenshots**  
  Captured automatically on failure.

---

## Logging

- **run.log**  
  Detailed, step-level logs including:
  - Node execution start/end
  - LLM invocation
  - Parsing and validation failures
  - Executor activity
  - Execution timing

---

## How to Run

### 1. Install Dependencies

```bash
pip install -r requirements.txt
python -m playwright install chromium


# Running the Application

## 2. Run the Application (UI)

```bash
python -m src.main

http://localhost:8501

>Run via CLI (Optional)
python -m src.main --story path/to/user_story.txt


# How LangGraph Is Used

LangGraph is the backbone of orchestration in this system.

Instead of chaining functions imperatively, the entire workflow is modeled as a stateful directed graph.

## Key Concepts Used

### Pipeline State
- A shared mutable state dictionary  
- Passed between nodes  
- Contains artifacts, paths, warnings, and execution metadata  

### Nodes
Each major phase is implemented as a node:
- Phase 1 generation  
- Artifact persistence  
- Test case generation  
- Test data handling  
- Gherkin generation  
- Playwright execution  

### Deterministic Transitions
- No hidden side effects  
- Each node declares exactly what it reads and writes  

### Conditional Routing
Example:
- Generate test data  
- Ingest user-provided test data  
- Routing is decided dynamically based on pipeline state.  

### Explicit End State
Execution completes only after:
- Artifacts are written  
- Gherkin is generated  
- Tests are executed  
- Reports are produced  

## Why LangGraph Matters Here
LangGraph enables:
- Deterministic execution order  
- Clear failure boundaries  
- Resume-friendly design  
- Observability (easy to log each node)  
- Future extensibility (parallelism, retries, CI hooks)  

This makes the system agentic, not just a sequence of scripts.

## Summary
With a single user story as input, Agentic QA Studio:
- Understands the intent  
- Designs test cases  
- Generates or ingests test data  
- Produces executable Gherkin  
- Executes real browser tests  
- Generates reports and logs  

All of this is orchestrated deterministically using LangGraph.
